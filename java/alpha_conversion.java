import java.util.*;

/**
 * Alpha-conversion class make sure that all the variables generated by K-Normalization are different
 * a Hash Map structure created to implement that, by mapping the input variable with the existing variables
 * stored in the hash map. If existed, then generate a new variable and add it to them
 * Otherwise, alpha-conversion pass it to the next phase.   
 * 
 * Followed the pseudo-code mentioned in the project paper.
 * */

class alpha_conversion implements ObjVisitor<Exp> {

    HashMap<String,List> hm = new HashMap<String,List>();
    // HashMap<String,String> hm = new HashMap<String,String>();
	
	static int x = -1;
	static int level = 0;
    static String gen() {
        x++;
        return "temp" + x;
    }
    
    public alpha_conversion(int x) {
    	this.x = x;
    }

    public void displayHashMap(){
        Set set = hm.entrySet();
        Iterator i = set.iterator();
        System.out.println("Display Hashmap:");
        while(i.hasNext()) {
             Map.Entry me = (Map.Entry)i.next();
             System.out.print(me.getKey() + ": ");
             System.out.println(me.getValue());
        }
    }
    
    public Exp visit(Unit e) {
        //System.out.println("Current exp is " + e.toString());
        return e;
    }

    public Exp visit(Bool e) {
        //System.out.println("Current exp is " + e.toString());
        return e;
    }

    public Exp visit(Int e) {
        // System.out.println("Current exp is " + e.toString());
        return e;
    }

    public Exp visit(Float e) {
        // System.out.println("Current exp is " + e.toString());
        return e;
    }

    public Exp visit(Not e) {
        // System.out.println("Current exp is " + e.toString());
        return new Not(e.e.accept(this));
    }

    public Exp visit(Neg e) {
        // System.out.println("Current exp is " + e.toString());
        return new Neg(e.e.accept(this));
    }

    public Exp visit(Add e) {
        Add a = new Add(e.e1.accept(this), e.e2.accept(this));
        return a;
    }

	public Exp visit(Sub e) {
        Sub a = new Sub(e.e1.accept(this), e.e2.accept(this));
        return a;
    }

    public Exp visit(FNeg e){
    	return new FNeg(e.e.accept(this));
    }

    public Exp visit(FAdd e){
    	return new FAdd(e.e1.accept(this),e.e2.accept(this));
    }

    public Exp visit(FSub e){
    	return new FSub(e.e1.accept(this),e.e2.accept(this));
    }

    public Exp visit(FMul e) {
    	return new FMul(e.e1.accept(this),e.e2.accept(this));
    }

    public Exp visit(FDiv e){
    	return new FDiv(e.e1.accept(this),e.e2.accept(this));
    }

    public Exp visit(Eq e){
    	return new Eq(e.e1.accept(this),e.e2.accept(this));
    }

    public Exp visit(LE e){
    	return new LE(e.e1.accept(this),e.e2.accept(this));
    }

    public Exp visit(If e){
       If si = new If(e.e1.accept(this),e.e2.accept(this),e.e3.accept(this));
       return si;
       //TODO is that working ?
    }

    public Exp visit(Let e) {
        if (hm.containsKey(e.id.id)){
            Exp e11 = e.e1.accept(this);
            // System.out.println(e.id.id + " DOES exist");
            Var v = new Var(new Id(gen()));
            hm.get(e.id.id).add(v.id);
            Let l = new Let(v.id,e.t,e11,e.e2.accept(this));
            // this.displayHashMap();
            return l;
        }else {
            // System.out.println(e.id.id + " DOES NOT exist");
            List<Id> newNameList = new ArrayList<Id>(); 
            newNameList.add(e.id);
            hm.put(e.id.id, newNameList);
            Let l = new Let(e.id,e.t,e.e1.accept(this),e.e2.accept(this));
            // this.displayHashMap();
            return l;
        }
    }

    public Exp visit(Var e){
        // System.out.println("Current exp is " + e.toString());
        if (hm.containsKey(e.id.id)){
            // System.out.println(e.id.id + " DOES exist. Its value is " + hm.get(e.id.id));
            // System.out.println("Replaced by " + hm.get(e.id.id).get(hm.get(e.id.id).size() - 1));
            Var newE = new Var((Id)hm.get(e.id.id).get(hm.get(e.id.id).size() - 1));
            return newE;
        }else {
            // System.out.println(e.id.id + " DOES NOT exist");
            List<String> newNameList = new ArrayList<String>(); 
            newNameList.add(e.id.id);
            hm.put(e.id.id, newNameList);
            return e;
        }
    }
    

    // print sequence of identifiers 
    static <E> Exp printInfix(List<E> l, String op) {
        if (l.isEmpty()) {
            return new Unit();
        }
        Iterator<E> it = l.iterator();
        it.next();
        while (it.hasNext()) {
            it.next();
        }
        return new Unit();
    }

   
	// print sequence of Exp
    List<Exp> printInfix2(List<Exp> l) {
    	List<Exp> new_list = new LinkedList<Exp>();
    	new_list.clear();
        if (l.isEmpty()) {
            new_list.add(new Unit());
        }
        Iterator<Exp> it = l.iterator();
        while (it.hasNext()) {
        	  new_list.add(it.next().accept(this));
        }
        return new_list;
    }

    public Exp visit(LetRec e){
    	
    	FunDef fd2= new FunDef(e.fd.id, e.fd.type, e.fd.args, e.fd.e/*.accept(this)*/);
    	LetRec lr = new LetRec(fd2, e.e.accept(this));
    	return lr;
    	
    	/*FunDef fd2;
    	if (hm.containsKey(e.fd.id.id)){
            Var v = new Var(new Id(gen()));
            hm.get(e.fd.id.id).add(v.id);
             fd2 = new FunDef(v.id, e.fd.type, e.fd.args, e.fd.e.accept(this));
        }else {
            List<Id> newNameList = new ArrayList<Id>(); 
            newNameList.add(e.fd.id);
            hm.put(e.fd.id.id, newNameList);
             fd2 = new FunDef(e.fd.id, e.fd.type, e.fd.args, e.fd.e.accept(this));
        }
    	LetRec lr = new LetRec(fd2, e.e.accept(this));
    	return lr;*/
    	
    }

    public Exp rec_app(Exp e, Exp app) {
    	Let l = (Let)e;
    	if (l.id.id.equals("\0")) {
    		System.out.println(l.id.id);
    		return app;
    	}else {
    		return (Exp) new Let(l.id,l.t,l.e1,rec_app(l.e2,app));
    	}
    }
    
    public Exp visit(App e){
       App app = new App(e.e.accept(this),printInfix2(e.es));
       return app;
    	/*List<Exp> l = printInfix2(e.es);
    	Iterator it = l.iterator();
    	List<Exp> l2 = new LinkedList<Exp>();
    	Let new_l = new Let(new Id("\0"),new TInt(),new Unit(),new Unit());
    	while (it.hasNext()) {
    		Exp exp = (Exp) it.next();
    		if(exp.getClass()==Let.class){

        		System.out.println("YO");
    			Let lt = (Let) exp;
    			l2.add(new Var(lt.id));
    			new_l = new Let(lt.id,lt.t,lt.e1,new_l);
    		}else {
    			l2.add(exp);
    		}
    	}
    	Exp app;
    	app = new App(e.e.accept(this),l2);
    	if (!new_l.id.id.equals("\0")) {
    		new_l = (Let) rec_app(new_l,app);
    		app = new_l;
    	}
       return app;*/
    }

    public Exp visit(Tuple e){
       Tuple t = new Tuple(printInfix2(e.es));
    	return t;
    }

    public Exp visit(LetTuple e){
       LetTuple lt = new LetTuple(e.ids,e.ts,e.e1.accept(this),e.e2.accept(this));
    	return lt;
    }

    public Exp visit(Array e){
    	Array a = new Array(e.e1.accept(this),e.e2.accept(this));
    	return a;
    }

    public Exp visit(Get e){
        Get g = new Get(e.e1.accept(this),e.e2.accept(this));
    	return g;
    }

    public Exp visit(Put e){
       Put p = new Put(e.e1.accept(this),e.e2.accept(this),e.e3.accept(this));
    	return p;
    }
}


